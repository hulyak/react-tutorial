(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{110:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/useeffect-hook-6ebddf30920fd5ed00e71b29e562788e.jpg"},111:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/effect-1e13b1bbd394bcc2502bbc56ab953a43.gif"},112:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/loop-88e5ec4cebcfde75d8c15e5069215fb8.gif"},113:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/source-c2ec0c39395e1c6042aba00bd8e844ce.gif"},114:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/dep-a5119a13a28b8432067aa79e0d5b43e3.gif"},115:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/dep2-29d8e9904535fe0f6b01a16869bc06ce.gif"},116:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/warning-6990fb5d2a4417722b41790d646b2538.png"},61:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),c=n(6),i=(n(0),n(75)),o={id:"The useEffect Hook",title:"The useEffect Hook"},r={unversionedId:"The useEffect Hook",id:"The useEffect Hook",isDocsHomePage:!1,title:"The useEffect Hook",description:"img",source:"@site/docs/doc3.md",slug:"/The useEffect Hook",permalink:"/react-tutorial/docs/The useEffect Hook",editUrl:"https://github.com/hulyak/react-tutorial/docs/doc3.md",version:"current",sidebar:"someSidebar",previous:{title:"The useState Hook",permalink:"/react-tutorial/docs/The useState Hook"},next:{title:"Demo App-Food Recipes",permalink:"/react-tutorial/docs/Demo App"}},s=[{value:"1. useEffect without a Dependency Array",id:"1-useeffect-without-a-dependency-array",children:[]},{value:"2. useEffect with an Empty Dependency Array",id:"2-useeffect-with-an-empty-dependency-array",children:[]},{value:"3. useEffect with a Non-empty Dependency Array",id:"3-useeffect-with-a-non-empty-dependency-array",children:[]},{value:"<code>useEffect</code> Cleanup",id:"useeffect-cleanup",children:[{value:"Side Notes",id:"side-notes",children:[]}]}],l={rightToc:s};function u(e){var t=e.components,o=Object(c.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,o,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("img",{alt:"img",src:n(110).default})),Object(i.b)("p",null,"If you\u2019ve written React class components before, you should be familiar with lifecycle methods like ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidMount"),", ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidUpdate"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"componentWillUnmount"),". The ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," Hook is all three of these lifecycle methods combined. It's used for side effects (all things which happen outside of React) like network requests, managing subscriptions, DOM manipulation, setting up event listeners, timeouts, intervals, or local storage, etc."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," functions run after every rerender by default.\nIt doesn't matter what caused the render like changing the state, or maybe new props, the effect will be triggered after rendering."),Object(i.b)("p",null,"Setting the title of the page will also be a side effect.\n",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," takes a callback function, we can tell ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," when the code we want to be executed with the second argument. This will control the effect."),Object(i.b)("p",null,"For the second argument, we can use ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," in three different ways:"),Object(i.b)("h2",{id:"1-useeffect-without-a-dependency-array"},"1. useEffect without a Dependency Array"),Object(i.b)("p",null,"It renders every time our app renders and at initial render."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// runs after every rerender\nuseEffect(() => {\n  console.log('I run after every render and at initial render');\n});\n")),Object(i.b)("p",null,"But we don't want to render each time, this can cause ",Object(i.b)("em",{parentName:"p"},"an infinite loop")," and we should avoid this."),Object(i.b)("p",null,"We need to optimize our components. We can pass ",Object(i.b)("em",{parentName:"p"},"a list of dependencies"),". The dependency will trigger an effect on the change of the dependencies."),Object(i.b)("p",null,"Let's see it in a simple example."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n//  src > components > UseEffect.js\n\nimport React, { useState, useEffect } from \'react\';\n\nconst UseEffect = ()  => {\n  const [count, setCount] = useState(0);\n  const [isOn, setIsOn] = useState(false;)\n\n// useEffect to set our document title to isOn\'s default state\n  useEffect(() => {\n    document.title = isOn;\n    console.log(\'first render\');\n  });\n\nconst handleClick = () => {\n  setIsOn(!isOn);\n  setCount(count + 1)\n}\n  return (\n  <div>\n    <h1>{isOn ? "ON" : "OFF"}</h1>\n    <h1>I was clicked {count} times</h1>\n    <button onClick={handleClick} className="btn">Click me</button>\n  </div>\n  );\n}\n\nexport default UseEffect;\n')),Object(i.b)("p",null,"In our example, we have two states: ",Object(i.b)("inlineCode",{parentName:"p"},"count")," and ",Object(i.b)("inlineCode",{parentName:"p"},"isOn"),". We are rendering these with our ",Object(i.b)("inlineCode",{parentName:"p"},"button")," and ",Object(i.b)("inlineCode",{parentName:"p"},"h1")," tags. When the button gets clicked, we are setting the ",Object(i.b)("inlineCode",{parentName:"p"},"isOn")," state to the opposite of its state."),Object(i.b)("p",null,"For the purpose of this example, we are setting ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," hook and changing our document title to our ",Object(i.b)("inlineCode",{parentName:"p"},"isOn"),"'s default value(false)."),Object(i.b)("p",null,"With our ",Object(i.b)("inlineCode",{parentName:"p"},"console.log"),", we can see that we rerender our component with our initial render and whenever we click the button. Because we don't have any array dependency."),Object(i.b)("p",null,Object(i.b)("img",{alt:"effect",src:n(111).default})),Object(i.b)("h2",{id:"2-useeffect-with-an-empty-dependency-array"},"2. useEffect with an Empty Dependency Array"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// runs at initial render\nuseEffect(() => {\n  console.log('I only run once');\n}, []);\n")),Object(i.b)("p",null,"This only runs once when the component is mounted or loaded."),Object(i.b)("p",null,"It looks exactly like the behavior of ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidMount")," in React classes. But we shouldn't compare with React class components."),Object(i.b)("h2",{id:"3-useeffect-with-a-non-empty-dependency-array"},"3. useEffect with a Non-empty Dependency Array"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// runs after every rerender if data has changed since last render\nuseEffect(() => {\n  console.log('I run whenever some piece of data has changed)');\n}, [id, value]);\n")),Object(i.b)("p",null,"If the variable is inside this array, we will trigger this effect only when the value of this variable changes, and not on each rerender. Any state or props we list in this array will cause ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," to re-run when they change."),Object(i.b)("p",null,"We can put our variables inside the dependency array from our component like any variables that we want for; for example, state variables, local variables, or props.\nThey adjust the array of dependencies."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// src > components > UseEffect.js\n\nimport React, { useState, useEffect } from 'react';\n\nconst UseEffect = () => {\n    const [ count, setCount ] = useState(0);\n    const [ isOn, setIsOn ] = useState(false);\n\n    useEffect(() => {\n      document.title = isOn;\n      // only difference from our previous example\n      setCount(count + 1);\n    });\n\n    const handleClick = () => {\n      setIsOn(!isOn);\n    };\n    \n    return (\n      <div>\n        <h1>{isOn ? 'ON' : 'OFF'}</h1>\n        <h1>I was clicked {count} times</h1>\n        <button onClick={handleClick} className=\"btn\">Click me</button>\n      </div>\n    );\n}\n\nexport default UseEffect;\n")),Object(i.b)("p",null,"We have just changed one line of code from the previous example and changed ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," a little, we will not increase our count with the button click. However, we will  trigger our effect whenever the ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," triggers. Let's see what will happen. "),Object(i.b)("p",null,Object(i.b)("img",{alt:"infinite loop",src:n(112).default})),Object(i.b)("p",null,Object(i.b)("img",{alt:"infinite loop",src:n(113).default})),Object(i.b)("p",null,"We are in an infinite loop; but why? React rerenders our component when the state changes. We are updating our state in our ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," function, and it's creating an infinite loop.  "),Object(i.b)("p",null,"I think no one wants to stuck in a loop; so, we need to find a way to get out of the loop and only run our function whenever our ",Object(i.b)("inlineCode",{parentName:"p"},"isOn")," state changes. For that, we will add our dependency array and pass our ",Object(i.b)("inlineCode",{parentName:"p"},"isOn")," state."),Object(i.b)("p",null,"The array of variables will decide if it should execute the function or not. It looks at the content of the array and compares the previous array, and if any of the value specified in the array changes compared to the previous value of the array, it will execute the effect function. If there is no change, it will not execute. "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// src > components > UseEffect.js\n\nimport React, { useState, useEffect } from 'react';\n\nconst UseEffect = () =>  {\n    const [ count, setCount ] = useState(0);\n    const [ isOn, setIsOn ] = useState(false);\n\n    useEffect(() => {\n      document.title = isOn;\n      setCount(count + 1);\n      // only add this\n    }, [isOn]);\n\n    const handleClick = () => {\n      setIsOn(!isOn);\n    };\n    \n    return (\n      <div>\n        <h1>{isOn ? 'ON' : 'OFF'}</h1>\n        <h1>I was clicked {count} times</h1>\n        <button onClick={handleClick} className=\"btn\">Click me</button>\n      </div>\n    );\n  }\n\nexport default UseEffect;\n")),Object(i.b)("p",null,Object(i.b)("img",{alt:"dep",src:n(114).default})),Object(i.b)("p",null,"It seems like working, at least we got rid of the infinite loop, when it updates ",Object(i.b)("inlineCode",{parentName:"p"},"count")," it will rerender the component. But if you noticed, we start counting from ",Object(i.b)("em",{parentName:"p"},"1")," instead of ",Object(i.b)("em",{parentName:"p"},"0"),". We render first at initial render, that's why we see ",Object(i.b)("em",{parentName:"p"},"1"),". This effect behaves as a ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidMount")," and ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidUpdate")," together. We can solve our problem by adding an ",Object(i.b)("inlineCode",{parentName:"p"},"if")," condition."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-JavaScript"})," if(count === 0 && !isOn) return;\n")),Object(i.b)("p",null,"This will only render at the first render, after that when we click the button, ",Object(i.b)("inlineCode",{parentName:"p"},"setIsOn")," will be true. Now, our code looks like this."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"import React, { useState, useEffect } from 'react';\n\nconst UseEffect = () =>  {\n    const [ count, setCount ] = useState(0);\n    const [ isOn, setIsOn ] = useState(false);\n\n    useEffect(() => {\n      document.title = isOn;\n      // add this to the code\n      if(count === 0 && !isOn) return;\n      setCount(count + 1);\n    }, [isOn]);\n\n    const handleClick = () => {\n      setIsOn(!isOn);\n    };\n    return (\n      <div>\n        <h1>{isOn ? 'ON' : 'OFF'}</h1>\n        <h1>I was clicked {count} times</h1>\n        <button onClick={handleClick} className=\"btn\">Click me</button>\n      </div>\n    );\n  }\n\nexport default UseEffect;\n")),Object(i.b)("p",null,Object(i.b)("img",{alt:"dep2",src:n(115).default})),Object(i.b)("p",null,"Okay, now it stars from 0. If you're checking the console, you may see a warning: "),Object(i.b)("p",null,Object(i.b)("img",{alt:"warning",src:n(116).default})),Object(i.b)("p",null,"We will not add ",Object(i.b)("inlineCode",{parentName:"p"},"count")," inside our dependency array because if the count changes, it will trigger a rerender. This will cause an ",Object(i.b)("em",{parentName:"p"},"infinite loop"),". We don't want to do this, that's why we will not edit our ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect"),". If you want, you can try it out."),Object(i.b)("h2",{id:"useeffect-cleanup"},Object(i.b)("inlineCode",{parentName:"h2"},"useEffect")," Cleanup"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," comes with a cleanup function that helps unmount the component, we can think of it is like ",Object(i.b)("inlineCode",{parentName:"p"},"componentWillUnmount")," lifecycle event. When we need to clear a subscription or clear setTimeout, we can use cleanup functions. When we run the code, the code first will clean up the old state, then will run the updated state. This can help us to remove unnecessary behavior or prevent memory leaking issues."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"useEffect(() => {\n  effect;\n  return () => {\n    cleanup;\n  };\n}, [input]);\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// src > components > Cleanup.js\n\nimport React, { useState, useEffect } from 'react';\n\nconst Cleanup = ()  => {\n  const [ count, setCount ] = useState(0);\n\n  useEffect(() => {\n  const intervalId = setInterval(() => {\n    setCount((prevCount) => prevCount + 1);\n    }, 1000);\n  return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n  <div>\n    <h1>{count}</h1>\n  </div>\n  );\n}\n\nexport default Cleanup;\n")),Object(i.b)("p",null,"We have defined a ",Object(i.b)("inlineCode",{parentName:"p"},"setInterval")," method inside our ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," hook, and our interval will run in the background. We are passing a function inside ",Object(i.b)("inlineCode",{parentName:"p"},"setInterval")," and it will update our ",Object(i.b)("inlineCode",{parentName:"p"},"count")," piece of state every second.\nOur ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," hook is only gonna run one time because we have our empty dependency array."),Object(i.b)("p",null,"To clean up our hook, we are creating our ",Object(i.b)("inlineCode",{parentName:"p"},"return")," function, getting our interval id, and passing inside our ",Object(i.b)("inlineCode",{parentName:"p"},"clearInterval")," method."),Object(i.b)("h3",{id:"side-notes"},"Side Notes"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"We can use multiple ",Object(i.b)("inlineCode",{parentName:"li"},"useEffect's")," in our application."),Object(i.b)("li",{parentName:"ul"},"We cannot mark ",Object(i.b)("inlineCode",{parentName:"li"},"useEffect")," as an ",Object(i.b)("inlineCode",{parentName:"li"},"async function"),"."),Object(i.b)("li",{parentName:"ul"},"React applies effect in the order they are created."),Object(i.b)("li",{parentName:"ul"},"We can make API calls to React in four different ways:")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Call ",Object(i.b)("inlineCode",{parentName:"li"},"fetch/Axios")," in your component"),Object(i.b)("li",{parentName:"ol"},"Make another file and store your API calls."),Object(i.b)("li",{parentName:"ol"},"Create a reusable custom hook."),Object(i.b)("li",{parentName:"ol"},"Use a library like ",Object(i.b)("inlineCode",{parentName:"li"},"react-query"),", ",Object(i.b)("inlineCode",{parentName:"li"},"SWR"),", etc.")),Object(i.b)("p",null,"We will use ",Object(i.b)("inlineCode",{parentName:"p"},"fetch")," in our application for simplicity. Now, ready to move on with our final demo app? Time to combine everything you have learned with a real-life application. This will be fun!!! \ud83d\ude07"))}u.isMDXComponent=!0}}]);